#!/usr/share/ucs-test/runner python
## desc: Test mail server rejecting forged From addresses
## exposure: dangerous
## packages: [univention-mail-server]

from essential.mail import check_delivery, check_ldap_bind, send_mail
import smtplib
import time
import syslog
import tempfile
import subprocess
import univention.testing.strings as uts
import univention.testing.ucr as ucr_test
import univention.testing.udm as udm_test
import univention.testing.utils as utils
from univention.config_registry import handler_set


domain = ''
postfix_restart = ['service', 'postfix', 'restart']
sender_check_smtp_reload = ['service', 'univention-postfix-sender-check-smtp', 'reload']
sender_check_non_smtp_reload = ['service', 'univention-postfix-sender-check-non-smtp', 'reload']


def check_sending_mail(sender_envelope, sender, recipient, username, password, should_be_accepted):
	token = str(time.time())
	try:
		ret_code = send_mail(recipients=recipient, sender=sender, msg=token, port=587, tls=True, username=username, password=password, sender_envelope=sender_envelope)
		if bool(ret_code) == should_be_accepted:
			msg = 'Sending should_be_accepted = {!r}, but return code = {!r}\n<empty dict> means there are no refused recipients'.format(should_be_accepted, ret_code)
			log(msg)
			utils.fail(msg)
		else:
			log('OK: mail was accepted.')
	except (smtplib.SMTPSenderRefused, smtplib.SMTPDataError) as exc:
		if should_be_accepted:
			msg = 'Mail sent failed with exception: {}'.format(exc)
			log(msg)
			utils.fail(msg)
		else:
			log('OK: mail was rejected: {}'.format(exc))


def log(msg):
	print(msg)
	syslog.syslog(syslog.LOG_INFO, msg)


def new_email(with_real_name=False, maildomain=None):
	email = '{}@{}'.format(uts.random_name(), maildomain or domain)
	if with_real_name:
		return 'Vor{} Nach{} <{}>'.format(uts.random_name(3), uts.random_name(3), email)
	else:
		return email


def example_email():
	return '{}@example.com'.format(uts.random_name())


def main():
	global domain

	with ucr_test.UCSTestConfigRegistry() as ucr:
		handler_set([
			'mail/postfix/smtpd_milters/50=inet:localhost:5656',
			'mail/postfix/non_smtpd_milters/50=inet:localhost:5657'
		])
		for k, v in sorted((k, v) for k, v in ucr.items() if '_milter' in k):
			print('*** UCRV {!r}={!r}'.format(k, v))

		with utils.AutoCallCommand(enter_cmd=postfix_restart, exit_cmd=postfix_restart) as acc1, \
				utils.AutoCallCommand(enter_cmd=sender_check_smtp_reload, exit_cmd=sender_check_smtp_reload) as acc2, \
				utils.AutoCallCommand(enter_cmd=sender_check_non_smtp_reload, exit_cmd=sender_check_non_smtp_reload) as acc3, \
				udm_test.UCSTestUDM() as udm:
			syslog.openlog(ident="test_48_sender_check", facility=syslog.LOG_MAIL)
			domain = ucr.get('domainname')
			password = uts.random_name()
			mpa = new_email()
			mpa_with_real_name = 'Vor{} Nach{} <{}>'.format(uts.random_name(3), uts.random_name(3), mpa)
			maa = new_email()
			maa_with_real_name = 'Vor{} Nach{} <{}>'.format(uts.random_name(3), uts.random_name(3), maa)
			user_dn, username = udm.create_user(
					password=password,
					mailHomeServer='{}.{}'.format(ucr['hostname'], domain),
					mailPrimaryAddress=mpa,
					mailAlternativeAddress=maa,
			)
			log('*** Created user {!r} ({}).'.format(username, user_dn))
			check_ldap_bind(user_dn, password)

			# authenticated

			log('*** Sending with correct FROM in envelope and header with email address only (mPA)...')
			check_sending_mail(mpa, mpa, mpa, mpa, password, True)

			log('*** Sending with correct FROM in envelope and header with real name (mPA)...')
			check_sending_mail(mpa_with_real_name, mpa_with_real_name, mpa_with_real_name, mpa, password, True)

			log('*** Sending with correct FROM in envelope and wrong From in header with email address only (mPA)...')
			check_sending_mail(mpa, new_email(), mpa, mpa, password, False)

			log('*** Sending with correct FROM in envelope and wrong From in header with real name (mPA)...')
			check_sending_mail(mpa_with_real_name, new_email(True), mpa_with_real_name, mpa, password, False)

			log('*** Sending with wrong FROM in envelope and correct From in header with email address only (mPA)...')
			check_sending_mail(new_email(), mpa, mpa, mpa, password, False)

			log('*** Sending with wrong FROM in envelope and correct From in header with real name (mPA)...')
			check_sending_mail(new_email(True), mpa_with_real_name, mpa_with_real_name, mpa, password, False)

			log('*** Sending with wrong FROM in envelope and wrong From in header with email address only...')
			check_sending_mail(new_email(), new_email(), mpa, mpa, password, False)

			log('*** Sending with wrong FROM in envelope and wrong From in header with real name...')
			check_sending_mail(new_email(True), new_email(True), mpa, mpa, password, False)

			log('*** Sending with correct FROM in envelope and header with email address only (mAA)...')
			check_sending_mail(maa, maa, mpa, mpa, password, True)

			log('*** Sending with correct FROM in envelope and header with real name (mAA)...')
			check_sending_mail(maa_with_real_name, maa_with_real_name, mpa_with_real_name, mpa, password, True)

			log('*** Sending with correct FROM in envelope and wrong From in header with email address only (mAA)...')
			check_sending_mail(maa, new_email(), mpa, mpa, password, False)

			log('*** Sending with correct FROM in envelope and wrong From in header with real name (mAA)...')
			check_sending_mail(maa_with_real_name, new_email(True), mpa, mpa, password, False)

			log('*** Sending with wrong FROM in envelope and correct From in header with email address only (mAA)...')
			check_sending_mail(new_email(), maa, mpa, mpa, password, False)

			log('*** Sending with wrong FROM in envelope and correct From in header with real name (mAA)...')
			check_sending_mail(new_email(True), maa_with_real_name, mpa, mpa, password, False)

			# not authenticated

			log('*** Sending w/o authenticating with correct FROM in envelope and header with email address only (mPA)...')
			check_sending_mail(mpa, mpa, mpa, None, None, False)

			log('*** Sending w/o authenticating with existing email in FROM in envelope and header with example.com...')
			check_sending_mail(mpa, example_email(), mpa, None, None, False)

			log('*** Sending w/o authenticating with non-existent email in FROM in envelope and header with example.com...')
			check_sending_mail(new_email(), example_email(), mpa, None, None, False)

			log('*** Sending w/o authenticating with example.com in FROM in envelope and header with existing email...')
			check_sending_mail(example_email(), mpa, mpa, None, None, False)

			log('*** Sending w/o authenticating with domain example.com in FROM in envelope and header with non-existent email...')
			check_sending_mail(example_email(), new_email(), mpa, None, None, False)

			# new domain
			new_domain = '{}.{}'.format(uts.random_name(), uts.random_name(3))
			log('*** new_domain={!r}'.format(new_domain))
			new_mpa = new_email(maildomain=new_domain)
			log('*** new_mpa={!r}'.format(new_mpa))

			# not created yet -> mail should be accepted

			log('*** Sending w/o authenticating with domain {} in FROM in envelope and header with non-existent email...'.format(new_domain))
			check_sending_mail(example_email(), new_email(maildomain=new_domain), mpa, None, None, True)

			log('*** Sending w/o authenticating with external FROM in envelope and header with email address only (new_mpa)...')
			check_sending_mail(new_mpa, new_mpa, mpa, None, None, True)

			log('*** Creating new domain...')
			lo = utils.get_ldap_connection()
			if lo.searchDn('objectClass=oxMailDomainServerSettings'):
				udm_module = 'oxmail/oxdomain'
			else:
				udm_module = 'mail/domain'

			udm.create_object(
				udm_module,
				name=new_domain,
				position="cn=domain,cn=mail,{}".format(ucr['ldap/base'])
			)
			log('*** Created new domain {!r}.'.format(new_domain))

			# reload has been done by listener module hosteddomains.py

			password2 = uts.random_name()
			user_dn2, username2 = udm.create_user(
					password=password2,
					mailHomeServer='{}.{}'.format(ucr['hostname'], domain),
					mailPrimaryAddress=new_mpa,
			)
			log('*** Created user {!r} ({}).'.format(user_dn2, username2))
			check_ldap_bind(user_dn2, password2)

			log('*** Sending with existing email in FROM in envelope and header with email address only (new_mpa)...')
			check_sending_mail(new_mpa, new_mpa, mpa, new_mpa, password2, True)

			log('*** Sending with existing email in FROM in envelope and wrong From in header with email address only (new_mpa)...')
			check_sending_mail(new_mpa, new_email(maildomain=new_domain), mpa, mpa, password, False)

			log('*** Sending with wrong FROM in envelope and correct From in header with email address only (new_mpa)...')
			check_sending_mail(new_email(maildomain=new_domain), new_mpa, mpa, mpa, password, False)

			log('*** Sending w/o authenticating with existing email in FROM in envelope and header with email address only (new_mpa)...')
			check_sending_mail(new_mpa, new_mpa, mpa, None, None, False)

			log('*** Sending w/o authenticating with existing email in FROM in envelope and header with example.com...')
			check_sending_mail(new_mpa, example_email(), mpa, None, None, False)

			log('*** Sending w/o authenticating with non-existent email in FROM in envelope and header with example.com...')
			check_sending_mail(new_email(maildomain=new_domain), example_email(), mpa, None, None, False)

			log('*** Sending w/o authenticating with example.com in FROM in envelope and header with existing email...')
			check_sending_mail(example_email(), new_mpa, mpa, None, None, False)

			log('*** Sending w/o authenticating with example.com in FROM in envelope and header with non-existent email...')
			check_sending_mail(example_email(), new_email(maildomain=new_domain), mpa, None, None, False)

			# test whitelist
			whitelisted_email = new_email()
			handler_set(['mail/postfix/sender_check_milter_whitelist={}'.format(whitelisted_email)])
			subprocess.call(['service', 'univention-postfix-sender-check-smtp', 'reload'])
			subprocess.call(['service', 'univention-postfix-sender-check-non-smtp', 'reload'])

			log('*** Sending w/o authenticating with whitelisted FROM in envelope and header...')
			check_sending_mail(whitelisted_email, whitelisted_email, mpa, None, None, True)

			log('*** Sending w/o authenticating with whitelisted FROM in envelope and example.com in header...')
			check_sending_mail(whitelisted_email, example_email(), mpa, None, None, True)

			log('*** Sending w/o authenticating with example.com in FROM in envelope and whitelisted header...')
			check_sending_mail(example_email(), whitelisted_email, mpa, None, None, True)

			new_mpa2 = new_email(maildomain=new_domain)
			user_dn3, username3 = udm.create_user(
					password=uts.random_name(),
					mailHomeServer='{}.{}'.format(ucr['hostname'], domain),
					mailPrimaryAddress=new_mpa2,
			)
			log('*** Created user {!r} ({}).'.format(user_dn3, username3))

			log('*** Sending using sendmail binary with example.com in FROM in envelope and header...')
			token = str(time.time())
			with tempfile.TemporaryFile() as fp:
				fp.write(token)
				fp.flush()
				fp.seek(0)
				subprocess.call(['mail', '-s', uts.random_name(), '-r', example_email(), new_mpa2], stdin=fp)
			check_delivery(token, new_mpa2, True, check_root=False)
			check_delivery('X-univention-sender-check-', new_mpa2, False, check_root=False)  # zzz

			log('*** Sending using sendmail binary with existing email in FROM in envelope and header...')
			token = str(time.time())
			with tempfile.TemporaryFile() as fp:
				fp.write(token)
				fp.flush()
				fp.seek(0)
				subprocess.call(['mail', '-s', uts.random_name(), '-r', new_email(), new_mpa2], stdin=fp)
			check_delivery(token, new_mpa2, True, check_root=False)
			check_delivery('X-univention-sender-check-sig', new_mpa2, True, check_root=False)
			check_delivery('X-univention-sender-check-nonce', new_mpa2, True, check_root=False)

			log('*** End of 48_sender_check')


if __name__ == '__main__':
	main()
