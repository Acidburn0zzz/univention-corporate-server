#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
#
# Univention mail Postfix
#  check allowed email senders
#
# Copyright 2018 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

"""
Milter that rejects mails with forged addresses in both

	* the envelope (MAIL FROM protocol stage)
	* the "From" header (DATA protocol stage)

Legitimate sender addresses for a user are found in its LDAP object in the
attributes 'mailPrimaryAddress' (MPA), `mailAlternativeAddress' (mAA) and
`mailAllowedSenderAddress`.
`mailAllowedSenderAddress` may contain email addresses as well as usernames.
For each username, the corresponding users mPA and mAA are also accepted.

The Milter runs as a daemon process. It forks a separate process for each
connection. Another process holds a cache of legitimate email addresses
for use (both writing and reading) by all connection handler processes. The
email addresses are cached for the number of seconds configured in UCRV
mail/postfix/sender_check_milter_cache_ttl.

E-Mails from connections that are verified (using SASL) are cryptographically
signed. The signature can be verified by other UCS mail servers in the domain.

Documentation:

	* http://www.postfix.org/MILTER_README.html
	* https://stuffivelearned.org/doku.php?id=programming:python:python-libmilter
"""

import os
import re
import bz2
import sys
import json
import signal
import syslog
import datetime
import traceback
from multiprocessing.managers import SyncManager

from ldap.filter import filter_format
import libmilter as lm
import univention.uldap
from univention.config_registry import ConfigRegistry
from univention.mail.simple_crypt import SimpleAsymmetric, SimpleSymmetric, create_nonce

try:
	from typing import Dict, List, Optional, Text, Tuple, Union
except ImportError:
	pass


RSA_KEY_FILE = '/usr/lib/univention-mail-postfix/sender_check.key'
HEADER_SIG = 'X-univention-sender-check-sig'
HEADER_NONCE = 'X-univention-sender-check-nonce'
LEGITIMATE_ADDRESSES_CACHE_TTL_UCR = 'mail/postfix/sender_check_milter_cache_ttl'
LEGITIMATE_ADDRESSES_CACHE_TTL_UCRV_DEFAULT = 60
WHITELISTED_ADDRESSES_UCR = 'mail/postfix/sender_check_milter_whitelist'
_ucr = None


def get_ucr():
	global _ucr
	if not _ucr:
		_ucr = ConfigRegistry()
		_ucr.load()
	return _ucr


def reload_ucr():
	global _ucr
	_ucr.load()


class SenderCheckMilter(lm.ForkMixin, lm.MilterProtocol):
	_lo = None
	_ldap_secret_mtime = 0.0
	_current_data = {}  # to prevent repeatedly logging same configuration
	legitimate_address_cache = None  # type: Dict[str, Union[Tuple[datetime.datetime, List[str]], Dict[str, int]]]
	legitimate_address_cache_ttl = get_ucr().get(LEGITIMATE_ADDRESSES_CACHE_TTL_UCR, LEGITIMATE_ADDRESSES_CACHE_TTL_UCRV_DEFAULT)
	regex_email_with_brackets = re.compile(r'.*<(.+@.+\..+)>$')
	regex_email_no_brackets = re.compile(r'(.+@.+\..+)$')
	mail_domains = []  # type: List[str]
	public_keys = {}  # type: Dict[str, str]
	whitelisted_addresses = []  # type: List[str]

	def __init__(self, opts=0, protos=0):
		lm.MilterProtocol.__init__(self, opts, protos)
		lm.ForkMixin.__init__(self)

		self.sasl_login_name = self.envelope_from = self.reject_msg = self.queue_id = ''
		self.legitimate_addresses = self.recipients = []  # type: List[str]
		self.header_data = {}  # type: Dict[str, str]
		self.sign_msg = self.header_from_ok = self.envelope_from_ok = False
		self._nonce = 0
		self.ucr = get_ucr()

		if not self.mail_domains:
			self.mail_domains.extend(self.get_mail_domains())
		if self._current_data.get('mail_domains') != set(self.mail_domains):
			self._current_data['mail_domains'] = set(self.mail_domains)
			self.log('Mail domains: {}'.format(', '.join(self.mail_domains or ['None'])))
		if not self.public_keys:
			self.public_keys.update(self.get_public_keys())
		if self._current_data.get('public_keys') != set(self.public_keys.keys()):
			self._current_data['public_keys'] = set(self.public_keys.keys())
			self.log('Public keys: {}'.format(', '.join(self.public_keys.keys() or ['None'])))
		if not self.whitelisted_addresses:
			self.whitelisted_addresses.extend(sorted(self.ucr.get(WHITELISTED_ADDRESSES_UCR, '').split()))
		if self._current_data.get('whitelisted_addresses') != set(self.whitelisted_addresses):
			self._current_data['whitelisted_addresses'] = set(self.whitelisted_addresses)
			self.log('Whitelisted addresses: {}'.format(', '.join(self.whitelisted_addresses or ['None'])))
		fqdn = '{}.{}'.format(self.ucr['hostname'], self.ucr['domainname'])
		if fqdn not in self.public_keys:
			raise RuntimeError('Public key of this host ({!r}) not found. Run join script.'.format(fqdn))
		self.crypto = SimpleAsymmetric()
		self.crypto.load_keys(RSA_KEY_FILE)

	@classmethod
	def log(cls, msg, queue_id=None, level='INFO'):  # type: (str, Optional[str], Optional[str]) -> None
		if level == 'ERROR':
			level = 'ERR'
		try:
			syslog_level = getattr(syslog, 'LOG_{}'.format(level))
		except KeyError:
			syslog_level = syslog.LOG_INFO
		if queue_id:
			msg = '{}: {}'.format(queue_id, msg)
		syslog.syslog(syslog_level, msg)

	def clear_variables(self):
		self.sasl_login_name = self.envelope_from = self.reject_msg = self.queue_id = ''
		self.legitimate_addresses = self.recipients = []
		self.header_data = {}
		self.sign_msg = self.header_from_ok = self.envelope_from_ok = False
		self._nonce = 0

	@classmethod
	def get_lo(cls):
		secret_mtime = os.stat('/etc/listfilter.secret').st_mtime
		if not cls._lo or cls._ldap_secret_mtime < secret_mtime:
			cls._lo = univention.uldap.getMachineConnection(
				ldap_master=False,
				secret_file='/etc/listfilter.secret'
			)
			cls._ldap_secret_mtime = os.stat('/etc/listfilter.secret').st_mtime
		return cls._lo

	@classmethod
	def get_legitimate_addresses_for_username(cls, sasl_login_name, include_mail_allowed_sender_address=True):
		# type: (str, Optional[bool]) -> Tuple[datetime.datetime, List[str]]
		stats = cls.legitimate_address_cache['__stats']
		if sasl_login_name in cls.legitimate_address_cache:
			expiration, addresses = cls.legitimate_address_cache[sasl_login_name]
			if expiration > datetime.datetime.now():
				# manager doesn't update mutable values or items in dict and list proxies, has to be assigned
				stats['hit'] += 1
				cls.legitimate_address_cache['__stats'] = stats
				return expiration, addresses
			else:
				stats['hit_exp'] += 1

		stats['miss'] += 1
		cls.legitimate_address_cache['__stats'] = stats
		lo = cls.get_lo()
		ldap_attr = ['mailPrimaryAddress', 'mailAlternativeAddress', 'mailAllowedSenderAddress']
		ldap_filter = filter_format('(&(uid=%s)(objectclass=univentionMail))', (sasl_login_name,))
		ldap_result = lo.search(filter=ldap_filter, attr=ldap_attr)
		try:
			attrs = ldap_result[0][1]
		except IndexError:
			cls.log('Found no email address for sasl_login_name={!r}.'.format(sasl_login_name), 'ERROR')
			return datetime.datetime.now(), []
		else:
			addresses = attrs.get('mailPrimaryAddress', []) + attrs.get('mailAlternativeAddress', [])
			expiration = datetime.datetime.now() + datetime.timedelta(seconds=cls.legitimate_address_cache_ttl)

		if include_mail_allowed_sender_address:
			users_additional_addresses = attrs.get('mailAllowedSenderAddress', [])
			for users_additional_address in users_additional_addresses:
				if '@' in users_additional_address:
					addresses.append(users_additional_address)
				else:
					_exp, _res = cls.get_legitimate_addresses_for_username(users_additional_address, False)
					addresses.extend(_res)
					# the entry could be from cache, in which case we "inherit" its (lower) expiration date
					expiration = min(expiration, _exp)
		cls.legitimate_address_cache[sasl_login_name] = expiration, addresses
		return expiration, addresses

	@classmethod
	def get_mail_domains(cls):  # type: () -> List[str]
		lo = cls.get_lo()
		ldap_attr = ['cn']
		ldap_filter = 'objectClass=univentionMailDomainname'
		ldap_result = lo.search(filter=ldap_filter, attr=ldap_attr)
		return [attr['cn'][0] for dn, attr in ldap_result]

	@classmethod
	def get_public_keys(cls):  # type: () -> Dict[str, str]
		lo = cls.get_lo()
		ldap_attr = ['univentionData', 'univentionDataMeta']
		ldap_filter = '(&(objectClass=univentionData)(univentionDataType=mail/signing/RSA_public_key))'
		ldap_base = 'cn=data,cn=univention,{}'.format(get_ucr()['ldap/base'])
		ldap_result = lo.search(filter=ldap_filter, attr=ldap_attr, base=ldap_base)
		res = {}
		for dn, attrs in ldap_result:
			if not attrs.get('univentionData') or not attrs.get('univentionDataMeta'):
				cls.log('settings/data object without data or metadata: dn={!r} attrs={!r}'.format(dn, attrs), 'ERROR')
				continue
			for metadata in attrs['univentionDataMeta']:
				if metadata.startswith('host:'):
					try:
						bz2data = attrs['univentionData'][0]
						pem_str = bz2.decompress(bz2data)
					except (IndexError, ValueError):
						cls.log('Invalid data in {!r}.'.format(dn), 'ERROR')
						continue
					pub_key = SimpleAsymmetric.pem2public_key(pem_str)
					res[metadata[5:]] = pub_key  # strip leading 'host:'
		return res

	@classmethod
	def sig_handler_reload(cls, num, frame):
		"""
		Reload UCR, :py:attr`cls.mail_domains`, :py:attr`cls.public_keys` and
		purge :py:attr`cls.legitimate_address_cache`.
		"""
		reload_ucr()
		cls.mail_domains = cls.get_mail_domains()
		cls.public_keys = cls.get_public_keys()
		cls.legitimate_address_cache_ttl = get_ucr().get(LEGITIMATE_ADDRESSES_CACHE_TTL_UCR, LEGITIMATE_ADDRESSES_CACHE_TTL_UCRV_DEFAULT)
		cache_stats = cls.legitimate_address_cache['__stats'].copy()
		cls.legitimate_address_cache.clear()
		cls.legitimate_address_cache['__stats'] = {'hit': 0, 'hit_exp': 0, 'miss': 0}
		cls.whitelisted_addresses = sorted(get_ucr().get(WHITELISTED_ADDRESSES_UCR, '').split())
		SenderCheckForkFactory._ignore_interrupt = True
		cls.log('Reloaded. Mail domains: {}, Public keys: {}'.format(
			', '.join(cls.mail_domains or ['None']), ', '.join(cls.public_keys.keys() or ['None'])))
		cls.log('Cache hits: {}, Cache misses: {} (of those expired: {})'.format(
			cache_stats['hit'], cache_stats['miss'], cache_stats['hit_exp']))
		cls.log('Whitelisted addresses: {}'.format(', '.join(cls.whitelisted_addresses or ['None'])))

	@lm.noReply
	def connect(self, hostname, family, ip, port, cmdDict):
		self.clear_variables()
		return lm.CONTINUE

	def mailFrom(self, frAddr, cmdDict):
		self.envelope_from = frAddr
		if self.envelope_from in self.whitelisted_addresses:
			self.envelope_from_ok = True
			return lm.CONTINUE
		try:
			self.sasl_login_name = cmdDict['auth_authen']
		except KeyError:
			# not authenticated session
			local_part, at, domain = self.envelope_from.rpartition('@')
			if domain and domain in self.mail_domains:
				# delay REJECT until eoh() to check for header "X-univention-sender-check-sig"
				self.set_reject_message(
					'REJECT: Envelope_from ({}) of not authenticated user with hosted domain ({}).'.format(
					self.envelope_from, domain))
		else:
			# authenticated session
			if not self.legitimate_addresses:
				_exp, self.legitimate_addresses = self.get_legitimate_addresses_for_username(self.sasl_login_name)
			if self.envelope_from in self.legitimate_addresses:
				self.envelope_from_ok = True
			else:
				self.log('REJECT: Envelope_from ({}) not in legitimate addresses ({}) of {!r}.'.format(
					self.envelope_from, ', '.join(self.legitimate_addresses), self.sasl_login_name))
				return lm.REJECT
		return lm.CONTINUE

	def header(self, key, val, cmdDict):
		self.queue_id = cmdDict.get('i', '')  # is set, although doc says it is only set in DATA, EOH, EOM
		if key.lower() in ('from', 'to'):
			self.header_data[key.lower()] = self.get_only_email(val)
		elif key.lower() in ('date', 'subject', 'message-id', HEADER_SIG.lower(), HEADER_NONCE.lower()):
			self.header_data[key.lower()] = val

		if key.lower() == 'from':
			if not self.header_data['from']:
				self.log('Invalid email address: {!r}: {!r}.'.format(key, val), self.queue_id, 'ERROR')
				return lm.REJECT
			if self.header_data['from'] in self.whitelisted_addresses:
				self.header_from_ok = True
				return lm.CONTINUE
			if self.sasl_login_name:
				# authenticated session
				if not self.legitimate_addresses:
					_exp, self.legitimate_addresses = self.get_legitimate_addresses_for_username(self.sasl_login_name)
				if self.header_data['from'] in self.legitimate_addresses:
					self.header_from_ok = True
					return lm.CONTINUE
				else:
					self.log('REJECT: Header_from ({}) not in legitimate addresses ({!s}, {!s}) of {!r}.'.format(
						self.header_data['from'], val, ', '.join(self.legitimate_addresses), self.sasl_login_name), self.queue_id)
					return lm.REJECT
			else:
				# not authenticated session
				local_part, at, domain = self.header_data['from'].rpartition('@')
				if domain and domain in self.mail_domains:
					# delay REJECT until eoh() to check for header "X-univention-sender-check-sig"
					self.set_reject_message(
						'REJECT: Header_from ({}) of not authenticated user with hosted domain ({}).'.format(
						self.header_data['from'], domain))
					return lm.CONTINUE
		return lm.CONTINUE

	def eoh(self, cmdDict):
		# decide what to do with an unauthenticated session
		# check for delayed REJECT message and for header "X-univention-sender-check-sig" (and "-nonce")
		self.queue_id = cmdDict.get('i', '')  # get again, in case it isn't set in header()
		header_sig = self.header_data.get(HEADER_SIG.lower(), '')
		header_nonce = self.header_data.get(HEADER_NONCE.lower(), '')
		if self.envelope_from_ok and self.header_from_ok:
			if self.reject_msg:
				# this shouldn't happen, better safe than sorry -> reject
				self.log('From OK, but has reject message!', self.queue_id, 'ERROR')
				return lm.REJECT
			if self.header_data['from'] in self.whitelisted_addresses and self.envelope_from in self.whitelisted_addresses:
				msg = 'From OK ({} is whitelisted), '.format(self.envelope_from)
			else:
				msg = 'From OK, '
			if header_sig or header_nonce:
				msg += 'not verifying existing signature.'
				self.sign_msg = False
			else:
				msg += 'signing message.'
				self.sign_msg = True
			self.log(msg, self.queue_id)
		elif self.reject_msg:
			if not header_sig or not header_nonce:
				self.log(self.reject_msg, self.queue_id)
				return lm.REJECT
			self._nonce = self.decrypt_header_nonce(header_nonce)
			if not self._nonce:
				self.log(self.reject_msg, self.queue_id)
				return lm.REJECT
			test_addresses = {self.header_data['from'].lower(), self.envelope_from.lower()}
			for test_address in test_addresses:
				if self.verify_signature(header_sig, self.create_signature_text(from_address=test_address)):
					self.log('CONTINUE: Verified signature by {!r}.'.format(header_sig.split(';', 1)[0]), self.queue_id)
					return lm.CONTINUE
			else:
				if self.sasl_login_name:
					msg_user = ' of {!r}'.format(self.sasl_login_name)
				else:
					msg_user = ' of not authenticated user'
				self.log('REJECT: Message{} has no valid signature!'.format(msg_user), self.queue_id, 'ERROR')
				self.log(self.reject_msg, self.queue_id)
				return lm.REJECT
		else:
			# this shouldn't happen, better safe than sorry -> reject
			self.log('From not OK, but no reject message!', self.queue_id, 'ERROR')
			return lm.REJECT
		return lm.CONTINUE

	def eob(self, cmdDict):
		"""
		This is the callback where you can use modification methods,
		such as addHeader(), delRcpt(), etc.  If you return CONTINUE
		from this method, it will be the same as returning ACCEPT.
		"""
		if self.sign_msg:
			self.add_header_signature(self.create_signature_text())
			self.add_header_nonce(str(self.nonce))
		return lm.CONTINUE

	def close(self):
		# don't log unnecessarily
		pass

	def get_only_email(self, text):  # type: (str) -> str
		m = self.regex_email_with_brackets.match(text)
		if not m:
			m = self.regex_email_no_brackets.match(text)
		if not m:
			return ''
		return m.groups()[0]

	def set_reject_message(self, msg):  # type: (str) -> None
		if not self.reject_msg:
			self.reject_msg = msg

	@classmethod
	def my_translate(cls, s, del_chars):  # type: (Union[str, Text], Union[str, Text]) -> Union[str, Text]
		"""
		Remove characters in `del_chars` from string `s`.

		:param str s: string|unicode from which to remove characters in `del_chars`
		:param str del_chars: characters to remove from `s`
		:return: copy of `s` with characters in `del_chars` removed
		:rtype: str
		"""
		if isinstance(s, unicode):
			translate_table = dict((ord(x), None) for x in del_chars)
			return s.translate(translate_table)
		else:
			return s.translate(None, del_chars)

	@property
	def nonce(self):  # type: () -> int
		"""Generate a (instance-cached) cryptographically secure random number."""
		if not self._nonce:
			self._nonce = create_nonce()
		return self._nonce

	def create_signature_text(self, from_address=None, to=None, date=None, message_id=None):
		# type: (Optional[str], Optional[str], Optional[str], Optional[str]) -> str
		"""
		The signature text for the `X-univention-sender-check-sig` header is
		created from:

		* `From`
		* `To`
		* `Date`
		* `Message-Id`
		* nonce

		The `Subject` is normalized to handle modifications by spam filters.

		A nonce (random int) is added that will also be stored encrypted in a
		separate header (`X-univention-sender-check-nonce`).

		:param str from_address: an email address, envelope-FROM will be used
			if unset
		:param str to: an email address, header-To will be used if unset
		:param str date: a date, header-Date will be used if unset
		:param str message_id: the mails message-id, header-message-id will be
			used if unset
		:return: signature text
		:rtype: str
		"""
		return '|'.join((
			(from_address or self.envelope_from).lower(),
			(to or self.header_data.get('to', '')).lower(),
			date or self.header_data.get('date', ''),
			message_id or self.header_data.get('message-id'),
			str(self.nonce),
		))

	def add_header_nonce(self, nonce):  # type: (str) -> None
		symmetric_key, cyphertext = SimpleSymmetric.encrypt(nonce)
		data = {'cyphertext': cyphertext}
		for host, pub_key in self.public_keys.items():
			data[host] = self.crypto.encrypt(symmetric_key, pub_key).encode('base64').strip()
		msg = json.dumps(data).encode('base64').strip()
		self.addHeader(HEADER_NONCE, msg)

	def decrypt_header_nonce(self, header_text):  # type: (str) -> str
		try:
			header = header_text.decode('base64')
		except ValueError:
			self.log('Invalid data in {}.'.format(HEADER_NONCE), self.queue_id, 'ERROR')
			return ''
		data = json.loads(header)
		try:
			cyphertext = data['cyphertext']
			enc_symmetric_key = data['{}.{}'.format(self.ucr['hostname'], self.ucr['domainname'])].decode('base64')
		except KeyError:
			self.log('Nonce was not encrypted for this host, only for: {!r}.'.format(data.keys()), self.queue_id, 'ERROR')
			return ''
		except ValueError:
			self.log('Invalid data in {}.'.format(HEADER_NONCE), self.queue_id, 'ERROR')
			return ''
		symmetric_key = self.crypto.decrypt(enc_symmetric_key)
		nonce = SimpleSymmetric.decrypt(cyphertext, symmetric_key)
		return nonce

	def remove_header_nonce(self):  # type: () -> None
		self.chgHeader(HEADER_NONCE, val='')

	def add_header_signature(self, text):  # type: (str) -> None
		signature = self.crypto.sign(text)
		sig = signature.encode('base64').strip()
		res = '{}.{};{}'.format(self.ucr['hostname'], self.ucr['domainname'], sig)
		self.addHeader(HEADER_SIG, res)

	def remove_header_signature(self):  # type: () -> None
		self.chgHeader(HEADER_SIG, val='')

	def verify_signature(self, signature, text):  # type: (str, str) -> bool
		host, _sep, signature = signature.partition(';')
		try:
			rsa_pub_key = self.public_keys[host]
		except KeyError:
			self.log('No public key registered for host {!r}.'.format(host), self.queue_id, 'ERROR')
			return False
		try:
			sig = signature.decode('base64')
		except ValueError:
			self.log('Invalid data in {}.'.format(HEADER_SIG), self.queue_id, 'ERROR')
			return False
		return self.crypto.verify(sig, text, rsa_pub_key)


class SenderCheckForkFactory(lm.ForkFactory):
	_ignore_interrupt = False

	def log(self, msg):
		if self._ignore_interrupt and 'Interrupted system call' in msg:
			# process received a signal, the blocking self.sock.accept() in
			# run() will create a socket.error. This is not a problem because
			# it is inside a "while True" loop.
			# -> Suppress logging it to not produce useless tickets.
			SenderCheckForkFactory._ignore_interrupt = False
			return
		SenderCheckMilter.log(msg)


def sync_manager_init():
	signal.signal(signal.SIGINT, signal.SIG_IGN)
	signal.signal(signal.SIGTERM, signal.SIG_IGN)
	signal.signal(signal.SIGHUP, signal.SIG_IGN)


def run_milter():
	syslog.openlog(ident="sender_check", logoption=syslog.LOG_PID, facility=syslog.LOG_MAIL)
	ucr = get_ucr()
	port = ucr.get('mail/postfix/sender_check_milter_port', 5656)
	SenderCheckMilter.log('Starting sender_check milter process. Listening on port {}.'.format(port))
	# test LDAP connection
	SenderCheckMilter.get_lo()

	opts = lm.SMFIP_NOHELO | lm.SMFIP_NORCPT | lm.SMFIP_NOBODY | lm.SMFIP_NODATA | lm.SMFIF_ADDHDRS | lm.SMFIF_CHGHDRS
	sync_manager = SyncManager()
	sync_manager.start(sync_manager_init)
	SenderCheckMilter.legitimate_address_cache = sync_manager.dict({'__stats': {'hit': 0, 'hit_exp': 0, 'miss': 0}})
	milter_factory = SenderCheckForkFactory('inet:127.0.0.1:{}'.format(port), SenderCheckMilter, opts)

	def shutdown():
		SenderCheckMilter.log('Stopping sender_check milter process.')
		SenderCheckMilter.log('Cache hits: {}, Cache misses: {} (of those expired: {})'.format(
			SenderCheckMilter.legitimate_address_cache['__stats']['hit'],
			SenderCheckMilter.legitimate_address_cache['__stats']['miss'],
			SenderCheckMilter.legitimate_address_cache['__stats']['hit_exp']))
		milter_factory.close()
		try:
			sync_manager.shutdown()
		except OSError as exc:
			if exc.errno != 3:  # "No such process" - no problem for us
				raise

	def sig_handler_shutdown(num, frame):
		shutdown()
		sys.exit(0)

	signal.signal(signal.SIGINT, sig_handler_shutdown)
	signal.signal(signal.SIGTERM, sig_handler_shutdown)
	signal.signal(signal.SIGHUP, SenderCheckMilter.sig_handler_reload)

	try:
		milter_factory.run()
	except Exception as exc:
		# print to journald/syslog and log to mail.log
		print('EXCEPTION OCCURRED: {}'.format(exc))
		traceback.print_tb(sys.exc_traceback)
		SenderCheckMilter.log('Exception in sender_check milter: {}'.format(exc), 'ERROR')
		for line in [l.replace('#012', '\n') for l in traceback.format_tb(sys.exc_traceback)]:
			for _line in [l for l in line.split('\n') if l]:
				SenderCheckMilter.log(_line, 'ERROR')
		sys.exit(1)
	finally:
		try:
			shutdown()
		except Exception:
			pass


if __name__ == '__main__':
	run_milter()
