#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
#
# Univention mail Postfix
#  check allowed email senders
#
# Copyright 2018 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

"""
Milter that rejects mails with forged addresses in both

	* the envelope (MAIL FROM protocol stage)
	* the "From" header (DATA protocol stage)

Legitimate sender addresses for a user are found in its LDAP object in the
attributes 'mailPrimaryAddress' (MPA), `mailAlternativeAddress' (mAA) and
`mailAllowedSenderAddress`.
`mailAllowedSenderAddress` may contain email addresses as well as usernames.
For each username, the corresponding users mPA and mAA are also accepted.

The Milter runs as a daemon process. It forks a separate process for each
connection. Another process holds a cache of legitimate email addresses
for use (both writing and reading) by all connection handler processes. The
email addresses are cached for the number of seconds configured in UCRV
mail/postfix/sender_check_milter_cache_ttl.

E-Mails from connections that are verified (using SASL) are cryptographically
signed. The signature can be verified by other UCS mail servers in the domain.

Documentation:

	* http://www.postfix.org/MILTER_README.html
	* https://stuffivelearned.org/doku.php?id=programming:python:python-libmilter
"""

import sys
import signal
import syslog
import datetime
import traceback
from multiprocessing.managers import SyncManager

from ldap.filter import filter_format
import libmilter as lm
from univention.mail.milter_base import UCSMilterForkFactory, UCSMilterBase
from univention.mail.sender_check_milter_base import SenderCheckMilterBase

try:
	from typing import Dict, List, Optional, Set, Text, Tuple, Union
except ImportError:
	pass


HEADER_SIG = 'X-univention-sender-check-sig'
HEADER_NONCE = 'X-univention-sender-check-nonce'
LEGITIMATE_ADDRESSES_CACHE_TTL_UCR = 'mail/postfix/sender_check_milter_cache_ttl'
LEGITIMATE_ADDRESSES_CACHE_TTL_UCRV_DEFAULT = 60
WHITELISTED_ADDRESSES_UCR = 'mail/postfix/sender_check_milter_whitelist'
UCRV_SMTP_MILTER_PORT = 'mail/postfix/sender_check_milter_port'


class SenderCheckSmtpMilter(SenderCheckMilterBase):
	legitimate_address_cache = None  # type: Dict[str, Union[Tuple[datetime.datetime, List[str]], Dict[str, int]]]
	legitimate_address_cache_ttl = SenderCheckMilterBase.get_ucr().get(LEGITIMATE_ADDRESSES_CACHE_TTL_UCR, LEGITIMATE_ADDRESSES_CACHE_TTL_UCRV_DEFAULT)
	whitelisted_addresses = []  # type: List[str]

	def __init__(self, opts=0, protos=0):  # type: (Optional[int], Optional[int]) -> None
		super(SenderCheckSmtpMilter, self).__init__(opts, protos)

		self.reject_msg = ''
		self.legitimate_addresses = self.recipients = []  # type: List[str]
		self.sign_msg = self.header_from_ok = self.envelope_from_ok = False

		if not self.whitelisted_addresses:
			self.whitelisted_addresses.extend(self.get_whitelisted_addresses())
		if self._current_data.get('whitelisted_addresses') != set(self.whitelisted_addresses):
			self._current_data['whitelisted_addresses'] = set(self.whitelisted_addresses)
			self.log('Whitelisted addresses: {}'.format(', '.join(self.whitelisted_addresses or ['None'])))

	def clear_variables(self):  # type: () -> None
		super(SenderCheckSmtpMilter, self).clear_variables()
		self.reject_msg = ''
		self.legitimate_addresses = self.recipients = []
		self.sign_msg = self.header_from_ok = self.envelope_from_ok = False

	@classmethod
	def get_whitelisted_addresses(cls):  # type: () -> List[str]
		return sorted(cls.get_ucr().get(WHITELISTED_ADDRESSES_UCR, '').split())

	@classmethod
	def get_legitimate_addresses_for_username(cls, sasl_login_name, include_mail_allowed_sender_address=True):
		# type: (str, Optional[bool]) -> Tuple[datetime.datetime, List[str]]
		stats = cls.legitimate_address_cache['__stats']
		if sasl_login_name in cls.legitimate_address_cache:
			expiration, addresses = cls.legitimate_address_cache[sasl_login_name]
			if expiration > datetime.datetime.now():
				# manager doesn't update mutable values or items in dict and list proxies, has to be assigned
				stats['hit'] += 1
				cls.legitimate_address_cache['__stats'] = stats
				return expiration, addresses
			else:
				stats['hit_exp'] += 1

		stats['miss'] += 1
		cls.legitimate_address_cache['__stats'] = stats
		lo = cls.get_lo()
		ldap_attr = ['mailPrimaryAddress', 'mailAlternativeAddress', 'mailAllowedSenderAddress']
		ldap_filter = filter_format('(&(uid=%s)(objectclass=univentionMail))', (sasl_login_name,))
		ldap_result = lo.search(filter=ldap_filter, attr=ldap_attr)
		try:
			attrs = ldap_result[0][1]
		except IndexError:
			cls.log('Found no email address for sasl_login_name={!r}.'.format(sasl_login_name), 'ERROR')
			return datetime.datetime.now(), []
		else:
			addresses = attrs.get('mailPrimaryAddress', []) + attrs.get('mailAlternativeAddress', [])
			expiration = datetime.datetime.now() + datetime.timedelta(seconds=cls.legitimate_address_cache_ttl)

		if include_mail_allowed_sender_address:
			users_additional_addresses = attrs.get('mailAllowedSenderAddress', [])
			for users_additional_address in users_additional_addresses:
				if '@' in users_additional_address:
					addresses.append(users_additional_address)
				else:
					_exp, _res = cls.get_legitimate_addresses_for_username(users_additional_address, False)
					addresses.extend(_res)
					# the entry could be from cache, in which case we "inherit" its (lower) expiration date
					expiration = min(expiration, _exp)
		addresses = sorted(set(addresses))
		cls.legitimate_address_cache[sasl_login_name] = expiration, addresses
		return expiration, addresses

	@classmethod
	def sig_handler_reload(cls, num, frame):
		"""
		Reload UCR, :py:attr`cls.mail_domains`, :py:attr`cls.public_keys`,
		:py:attr`cls.whitelisted_addresses` and purge :py:attr`cls.legitimate_address_cache`.
		"""
		super(SenderCheckSmtpMilter, cls).sig_handler_reload(num, frame)
		cls.whitelisted_addresses = sorted(cls.get_ucr().get(WHITELISTED_ADDRESSES_UCR, '').split())
		cls.log('Whitelisted addresses: {}'.format(', '.join(cls.whitelisted_addresses or ['None'])))
		cls.legitimate_address_cache_ttl = cls.get_ucr().get(LEGITIMATE_ADDRESSES_CACHE_TTL_UCR, LEGITIMATE_ADDRESSES_CACHE_TTL_UCRV_DEFAULT)
		cache_stats = cls.legitimate_address_cache['__stats'].copy()
		cls.legitimate_address_cache.clear()
		cls.legitimate_address_cache['__stats'] = {'hit': 0, 'hit_exp': 0, 'miss': 0}
		cls.log('Cache hits: {}, Cache misses: {} (of those expired: {})'.format(
			cache_stats['hit'], cache_stats['miss'], cache_stats['hit_exp']))

	def mailFrom(self, frAddr, cmdDict):  # type: (str, Dict[str, str]) -> None
		super(SenderCheckSmtpMilter, self).mailFrom(frAddr, cmdDict)

		if self.envelope_from in self.whitelisted_addresses:
			self.envelope_from_ok = True
			return lm.CONTINUE
		try:
			self.sasl_login_name = cmdDict['auth_authen']
		except KeyError:
			# not authenticated session
			local_part, at, domain = self.envelope_from.rpartition('@')
			if domain and domain in self.mail_domains:
				# delay REJECT until eoh() to check for header "X-univention-sender-check-sig"
				self.set_reject_message(
					'REJECT: Envelope_from ({}) of not authenticated user with hosted domain ({}).'.format(
					self.envelope_from, domain))
		else:
			# authenticated session
			if not self.legitimate_addresses:
				_exp, self.legitimate_addresses = self.get_legitimate_addresses_for_username(self.sasl_login_name)
			if self.envelope_from in self.legitimate_addresses:
				self.envelope_from_ok = True
			else:
				self.log('REJECT: Envelope_from ({}) not in legitimate addresses ({}) of {!r}.'.format(
					self.envelope_from, ', '.join(self.legitimate_addresses), self.sasl_login_name))
				return lm.REJECT
		return lm.CONTINUE

	def header(self, key, val, cmdDict):  # type: (str, str, Dict[str, str]) -> None
		super(SenderCheckSmtpMilter, self).header(key, val, cmdDict)

		self.queue_id = cmdDict.get('i', '')  # is set, although doc says it is only set in DATA, EOH, EOM
		if key.lower() in ('from', 'to'):
			self.header_data[key.lower()] = self.get_only_email(val)
		elif key.lower() in ('date', 'subject', 'message-id', HEADER_SIG.lower(), HEADER_NONCE.lower()):
			self.header_data[key.lower()] = val

		if key.lower() == 'from':
			if not self.header_data['from']:
				self.log('Invalid email address: {!r}: {!r}.'.format(key, val), self.queue_id, 'ERROR')
				return lm.REJECT
			if self.header_data['from'] in self.whitelisted_addresses:
				self.header_from_ok = True
				return lm.CONTINUE
			if self.sasl_login_name:
				# authenticated session
				if not self.legitimate_addresses:
					_exp, self.legitimate_addresses = self.get_legitimate_addresses_for_username(self.sasl_login_name)
				if self.header_data['from'] in self.legitimate_addresses:
					self.header_from_ok = True
					return lm.CONTINUE
				else:
					self.log('REJECT: Header_from ({}) not in legitimate addresses ({!s}, {!s}) of {!r}.'.format(
						self.header_data['from'], val, ', '.join(self.legitimate_addresses), self.sasl_login_name), self.queue_id)
					return lm.REJECT
			else:
				# not authenticated session
				local_part, at, domain = self.header_data['from'].rpartition('@')
				if domain and domain in self.mail_domains:
					# delay REJECT until eoh() to check for header "X-univention-sender-check-sig"
					self.set_reject_message(
						'REJECT: Header_from ({}) of not authenticated user with hosted domain ({}).'.format(
						self.header_data['from'], domain))
					return lm.CONTINUE
		return lm.CONTINUE

	def eoh(self, cmdDict):  # type: (Dict[str, str]) -> None
		# decide what to do with an unauthenticated session
		# check for delayed REJECT message and for header "X-univention-sender-check-sig" (and "-nonce")
		super(SenderCheckSmtpMilter, self).eoh(cmdDict)
		header_sig = self.header_data.get(HEADER_SIG.lower(), '')
		header_nonce = self.header_data.get(HEADER_NONCE.lower(), '')
		if self.envelope_from_ok and self.header_from_ok:
			if self.reject_msg:
				# this shouldn't happen, better safe than sorry -> reject
				self.log('From OK, but has reject message!', self.queue_id, 'ERROR')
				return lm.REJECT
			if self.header_data['from'] in self.whitelisted_addresses and self.envelope_from in self.whitelisted_addresses:
				msg = 'From OK ({} is whitelisted), '.format(self.envelope_from)
			else:
				msg = 'From OK, '
			if header_sig or header_nonce:
				msg += 'not verifying existing signature.'
				self.sign_msg = False
			else:
				msg += 'signing message.'
				self.sign_msg = True
			self.log(msg, self.queue_id)
		elif self.reject_msg:
			if not header_sig or not header_nonce:
				self.log(self.reject_msg, self.queue_id)
				return lm.REJECT
			self._nonce = self.decrypt_header_nonce(header_nonce)
			if not self._nonce:
				self.log(self.reject_msg, self.queue_id)
				return lm.REJECT
			test_addresses = {self.header_data['from'].lower(), self.envelope_from.lower()}
			for test_address in test_addresses:
				if self.verify_signature(header_sig, self.create_signature_text(from_address=test_address)):
					self.log('CONTINUE: Verified signature by {!r}.'.format(header_sig.split(';', 1)[0]), self.queue_id)
					return lm.CONTINUE
			else:
				if self.sasl_login_name:
					msg_user = ' of {!r}'.format(self.sasl_login_name)
				else:
					msg_user = ' of not authenticated user'
				self.log('REJECT: Message{} has no valid signature!'.format(msg_user), self.queue_id, 'ERROR')
				self.log(self.reject_msg, self.queue_id)
				return lm.REJECT
		elif self.header_data['from'] in self.legitimate_addresses or self.envelope_from in self.legitimate_addresses:
			# this shouldn't happen, better safe than sorry -> reject
			self.log('From not OK, but no reject message!', self.queue_id, 'ERROR')
			return lm.REJECT
		return lm.CONTINUE

	def eob(self, cmdDict):  # type: (Dict[str, str]) -> None
		"""
		This is the callback where you can use modification methods,
		such as addHeader(), delRcpt(), etc.  If you return CONTINUE
		from this method, it will be the same as returning ACCEPT.
		"""
		if self.sign_msg:
			self.add_header_signature(self.create_signature_text())
			self.add_header_nonce(str(self.nonce))
		return lm.CONTINUE

	def set_reject_message(self, msg):  # type: (str) -> None
		if not self.reject_msg:
			self.reject_msg = msg

	def dataReceived(self , buf):
		try:
			return super(SenderCheckSmtpMilter, self).dataReceived(buf)
		except Exception as exc:
			traceback.print_tb(sys.exc_traceback)
			self.log('Exception: {} when receiving data.'.format(exc), 'ERROR')
			self.log('data={!r}'.format(buf), 'ERROR')
			for line in [l.replace('#012', '\n') for l in traceback.format_tb(sys.exc_traceback)]:
				for _line in [l for l in line.split('\n') if l]:
					SenderCheckSmtpMilter.log(_line, 'ERROR')
			raise

def sync_manager_init():  # type: () -> None
	signal.signal(signal.SIGINT, signal.SIG_IGN)
	signal.signal(signal.SIGTERM, signal.SIG_IGN)
	signal.signal(signal.SIGHUP, signal.SIG_IGN)


def run_milter():  # type: () -> None
	syslog.openlog(ident="sender_check_smtp", logoption=syslog.LOG_PID, facility=syslog.LOG_MAIL)
	ucr = SenderCheckSmtpMilter.get_ucr()
	port = ucr.get(UCRV_SMTP_MILTER_PORT, 5656)
	SenderCheckSmtpMilter.log('Starting SMTP sender_check milter process. Listening on port {}.'.format(port))
	# test LDAP connection
	SenderCheckSmtpMilter.get_lo()

	opts = lm.SMFIP_NOHELO | lm.SMFIP_NORCPT | lm.SMFIP_NOBODY | lm.SMFIP_NODATA | lm.SMFIF_ADDHDRS | lm.SMFIF_CHGHDRS
	sync_manager = SyncManager()
	sync_manager.start(sync_manager_init)
	SenderCheckSmtpMilter.legitimate_address_cache = sync_manager.dict({'__stats': {'hit': 0, 'hit_exp': 0, 'miss': 0}})
	milter_factory = UCSMilterForkFactory('inet:127.0.0.1:{}'.format(port), SenderCheckSmtpMilter, opts)

	def shutdown():
		SenderCheckSmtpMilter.log('Stopping SMTP sender_check milter process.')
		SenderCheckSmtpMilter.log('Cache hits: {}, Cache misses: {} (of those expired: {})'.format(
			SenderCheckSmtpMilter.legitimate_address_cache['__stats']['hit'],
			SenderCheckSmtpMilter.legitimate_address_cache['__stats']['miss'],
			SenderCheckSmtpMilter.legitimate_address_cache['__stats']['hit_exp']))
		milter_factory.close()
		try:
			sync_manager.shutdown()
		except OSError as exc:
			if exc.errno != 3:  # "No such process" - no problem for us
				raise

	def sig_handler_shutdown(num, frame):
		shutdown()
		sys.exit(0)

	signal.signal(signal.SIGINT, sig_handler_shutdown)
	signal.signal(signal.SIGTERM, sig_handler_shutdown)
	signal.signal(signal.SIGHUP, SenderCheckSmtpMilter.sig_handler_reload)

	try:
		milter_factory.run()
	except Exception as exc:
		# print to journald/syslog and log to mail.log
		print('EXCEPTION OCCURRED: {}'.format(exc))
		traceback.print_tb(sys.exc_traceback)
		SenderCheckSmtpMilter.log('Exception in sender_check milter: {}'.format(exc), 'ERROR')
		for line in [l.replace('#012', '\n') for l in traceback.format_tb(sys.exc_traceback)]:
			for _line in [l for l in line.split('\n') if l]:
				SenderCheckSmtpMilter.log(_line, 'ERROR')
		sys.exit(1)
	finally:
		try:
			shutdown()
		except Exception:
			pass


if __name__ == '__main__':
	run_milter()
